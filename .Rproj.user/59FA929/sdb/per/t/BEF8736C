{
    "collab_server" : "",
    "contents" : "---\ntitle: \"2. Data Structures\"\nauthor: \"James Woodcock\"\noutput: \n    html_document:\n        toc: true\n        number_sections: true\n---\n\n```{r setup, include=FALSE, echo = FALSE}\nknitr::opts_chunk$set(echo = TRUE)\n```\n\n# Introduction \n\nR has a number of different internal datatypes which can be used to store varying pieces of data. In SAS we only need to worry about whether a variable is a numeric or character type, but here we have plenty more. This makes R (and almost all other languages) more complex than SAS, but also offers much more flexibility.\n\nData is stored in the form of variables, which just give a name to a piece of data so that we can use it later. A variable could be a number, character, list, dataset, or any number of other things. You could even assign a list of lists to a variable, which can be very helpful when you start to write more complex functions.\n\n# Variables\n\nWe can assign a value to a **variable**, and then print its value in the console, like below.\n```{r}\nx <- 1\nprint(x)\n```\n\nNotice that the assignment operator is \"<-\", and not \"=\" like in many other languages. Technically you could use \"=\" and it would do the same thing, however not always, and the difference is very subtle.\nWe can also manipulate variables, adding them together or multiplying them.\n\n```{r}\nx <- 1 # Integer\ny <- 2.3 # Floating point (\"double\")\nz <- pi \nprint(x + y + z)\n```\n\n# Common Data Types\n\n## Vectors\n\nVectors are simply a sequence of elements, where each entry is usually of the same data type. They can be declared using the <tt>c()</tt> function.\n\n```{r collapse=TRUE}\nnumVec <- c(1,2,3,4,5) # Declares a vector with 5 elements.\ncharVec <- c(\"Hello\", \"world.\")\nnumVec\ncharVec\n```\n\nElements of a vector can be accessed via square brackets after the variable name holding the vector. Note that vector indexes start from 1.\n\n```{r collapse=TRUE}\nnumVec[1]\ncharVec[2]\nnumVec[2:4] # Select elements 2 to 4, inclusive!\n```\nWe can also give names to the elements of a vector, and then reference the entries using this name. A possible use case for this: Say you want to store the median of each column in a dataset, the natural way to store these values would be in a vector, however you don't want to remember the position of each variable in order to use it later on. In this situation, a named vector would be useful as you could collect the mean of any variable from the vector you created using it's name.\n```{r collapse=TRUE}\nmeans <- c(0.002, 5.3, 3209.45, 35.88, 0.74)\nnames(means) <- c(\"DEFAULTS\", \"YEARS_ON_BOOK\", \"LIMIT\", \"AGE\", \"UTIL\")\nprint(means)\nmeans[\"DEFAULTS\"] # We can now reference by the column name.\n```\nNotice how the value we supply to <tt>names(means)</tt> is also a vector. R is a language built on vectors, so generally using them is the most efficient way to do things.\n\nVectors can also be concatenated with the <tt>c()</tt> function, with the following syntax.\n```{r}\nx <- c(1,2,3)\ny <- c(4,5,6)\nz <- c(x,y,c(7,8,9)) # We can nest c() statements inside a c() statement to\n                     # join vectors.\nz\n```\n\nWe can also perform **element-wise calculations** on vectors using normal mathematical notations. This is also works in the same way for matrices, which we will come onto next.\n\n```{r collapse=TRUE}\nx <- c(1,2,3)\ny <- c(2,3,4)\n\n2 * x * y # Multiplication\nx^2 # Squares each element of x\nx/y # Divides the element in x with the corresponding y element.\nlog(x) # Logarithm\nexp(y)\n\n```\n\n## Matrices\n\n### Creating a Matrix\nWe can think of matrices in basically the same way as vectors, apart from they have two dimensions rather than one. With matrices, we can start to see how real datasets can be stored in R. Creating matrices can be done in three different ways:\n```{r collapse=TRUE}\nmatrixA <- rbind(c(1,2,3),c(4,5,6)) # Build by rows.\nmatrixA\n\nmatrixB <- cbind(c(1,2,3),c(4,5,6)) # Build by columns. \nmatrixB\n\nmatrixC <- matrix(c(1,2,3,4,5,6), nrow = 2) # Internal representation, rarely used.\nmatrixC\n```\nThe first two methods are the most common, and easiest, ways to create a matrix. <tt>rbind()</tt> works by stacking rows up, given each row as a vector. In the opposite way, <tt>cbind</tt> stacks columns next to each other. So if we wanted to add a row to a matrix, we could use <tt>rbind</tt>, and if we wanted to add a row, use <tt>cbind</tt>.\n\n```{r collapse = TRUE}\nA = cbind(c(1,2),c(3,4))\nrbind(A, c(10,11)) # Add a row\ncbind(A, c(7,8)) # Add a column\n```\n\n### Referencing Elements\nWe can reference entries (as well as change them) in much the same way as with vectors, but now we need a row and column reference. For example, to change the 3rd row, 2nd column entry we could write:\n```{r,eval = FALSE, include = TRUE}\nA[3,2] <- 2 # Reference is [ROW, COLUMN]\n```\n\nWe can also select entire rows and columns of a matrix by leaving the reference blank inside the square brackets.\n```{r collapse=TRUE}\nA = diag(c(1,2,3,4,5,6))\nA\nA[,2] # Returns the second column of A.\nA[4,] # Return the fourth row.\nA[1:3,4] # Gives rows 1:3 of column 4.\n```\n\nNotice that <tt>A[,2]</tt> returns what looks like a row vector, when in usual maths it would be a column vector. This is because R has no differentiation between row and column vectors.\n\n### Calculations with Matrices\n\nLike vectors, we can perform **element-wise** calculations on matrices of the same dimensions.\n\n```{r collapse=TRUE}\nA <- rbind(c(1,2), c(3,4))\nA\nB <- rbind(c(2,2), c(3,3))\nB\n\nA + B\n\nA * B # Note that this is NOT matrix multiplication.\n\nA ^ B\n\nA / B\n```\n\nNote that the \\* operator does not mean matrix multiplication here. Instead we need to use the following syntax.\n\n```{r collapse = TRUE}\nA <- matrix(runif(16), ncol = 4)\nA\n\nB <- matrix(runif(16), ncol = 4)\nB\n\nA %*% B # Is the matrix multiplication of A and B.\n```\n\n## Lists\n\nLists are sort of like a vector, but each entry is named, and can contain any type of data that you choose. Lists are very powerful in R, and make the building blocks of the Object Oriented environment within R. The easiest way to explain lists is by demonstration.\n\n```{r}\nBasicList <- list(Name = c(\"James\", \"Sam\", \"Jed\", \"Adam\", \"Eve\"),\n             Age = c(23, 20, 39, 40, 13),\n             FavouriteFood = c(\"Lasange\",\"Monkey Nuts\",\"Pizza\", \"Calzones\", \"Bread\"))\n\nBasicList\n\n```\nWe can see from the output above that the variable <tt>BasicList</tt> has three sets of output, one for each of the elements that we have defined, which in this case are all vectors. We can access the elements of the list like so.\n\n```{r collapse=TRUE}\nBasicList$Name # Use $ followed by the element name.\n\nBasicList$Age[3] # We can then get the vector values like usual.\n\nBasicList[\"FavouriteFood\"] # Can also reference by name.\n\nBasicList[2] # Or by list position.\n```\nWe don't actually have to name our list elements, but in practice this is useful. If we don't have names for the elements, you can reference them numerically like in the last example above.\n\nLists don't just have to contain vectors. Take the following example:\n\n```{r}\ndata <- c(1,2,3,4,5,6,7,8,9,10)\nresponse <- c(4,6,8,10,12,14,16,18,20,22)\ndataSet <- data.frame(X = data, Y =response)\nlinearModel <- lm(data = dataSet, formula = Y ~ X)\nstr(linearModel)\n```\nHere we can see that the <tt>linearModel</tt> object <tt>lm</tt> is actually just a list (although it has a class). The list making up the linear model contains many different types of data, and even lists of lists.\n\n# Useful Functions\n\nBelow are a list of useful functions in R that do useful calculations.\n\n```{r collapse=TRUE}\nvec <- c(1,2,3,4,5)\nmat <- cbind(c(1,2,3),c(4,5,9),c(9,2,4))\nlist <- list(X = c(1,2,3), Y = c(4,5,6))\n\nis.list(vec) # Checks the type of a variable. Returns TRUE / FALSE\n\nis.list(list)\n\nsum(vec) # Sums the elements of a vector or matrix.\n\nvar(mat) # Gives the covariance matrix, or the variance for a vector. \n\nsd(mat) # Gives the standard deviation of all the elements of vectors or matrices.\n\nlength(vec) # Gives the length of the vector. Gives the number of columns of a matrix.\n            # Also gives the number of entries in a list.\n\nnrow(mat) # Returns the number of columns in a matrix.\n\nsolve(mat) # Gives the inverse of a square matrix.\n\nquantile(vec, c(0.25)) #  Gives the first quartile.\n\n```\n\nMany more useful functions can be found [here.](https://cran.r-project.org/doc/contrib/Short-refcard.pdf)\n\n\n\n\n\n\n\n\n\n",
    "created" : 1537976254079.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2197782393",
    "id" : "BEF8736C",
    "lastKnownWriteTime" : 1538483356,
    "last_content_update" : -2147483648,
    "path" : "C:/Users/JamesWoodcock/Google Drive/Training and Information/Training Sessions/Lunchtime R/2. Data Structures.rmd",
    "project_path" : "2. Data Structures.rmd",
    "properties" : {
        "last_setup_crc32" : ""
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}